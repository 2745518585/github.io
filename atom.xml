<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2745518585.github.io</id>
    <title>赵悦岑&apos;s Blog</title>
    <updated>2022-04-17T03:58:33.382Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2745518585.github.io"/>
    <link rel="self" href="https://2745518585.github.io/atom.xml"/>
    <subtitle>好好刷题，天天向上！</subtitle>
    <logo>https://2745518585.github.io/images/avatar.png</logo>
    <icon>https://2745518585.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 赵悦岑&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[P5030 长脖子鹿放置]]></title>
        <id>https://2745518585.github.io/post/solution-P5030/</id>
        <link href="https://2745518585.github.io/post/solution-P5030/">
        </link>
        <updated>2022-04-17T03:52:22.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P5030">P5030 长脖子鹿放置</a></p>
<h2 id="分析">分析</h2>
<p>  这道题和 P3355 很像，但是分组方法不一样。我们来看两个互相攻击的点有什么特点：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>⇔</mo><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y) \Leftrightarrow (x+1,y+3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>⇔</mo><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y) \Leftrightarrow (x-1,y+3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>⇔</mo><mo>(</mo><mi>x</mi><mo>−</mo><mn>3</mn><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y) \Leftrightarrow (x-3,y+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span>。显然，任意两个相互攻击的点横纵坐标的奇偶性都不相同。这样我们只需要按横坐标的奇偶性分组即可，虽然可以分成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 组，但是没有必要，只要保证同一组内不相互攻击即可。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const int N=50001,M=2000001;
int n,m,q,p=1,s1,s2,t[N],t0[N],f[N];
short dx[8]={-3,-1,1,3,3,1,-1,-3},dy[8]={-1,-3,-3,-1,1,3,3,1};
bool b[N];
struct str
{
    int m,q;
    ll r;
}a[M];
bool check(int x,int y)
{
    return x&gt;=1&amp;&amp;x&lt;=m&amp;&amp;y&gt;=1&amp;&amp;y&lt;=n;
}
int sum(int x,int y)
{
    return (x-1)*n+y;
}
void road(int x,int y,ll r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
bool bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s1);
    for(int i=1;i&lt;=s2;++i) f[i]=0;
    f[s1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].r!=0)
            {
                f[a[i].m]=f[k]+1;
                Q.push(a[i].m);
            }
        }
    }
    return f[s2]!=0;
}
ll dfs(int x,ll r)
{
    if(x==s2) return r;
    ll s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(f[a[i].m]==f[x]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
            else f[a[i].m]=0;
            if(r==0) return s; 
        }
    }
    return s;
}
int main()
{
    scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;q);
    s1=m*n+1;
    s2=m*n+2;
    for(int i=1;i&lt;=q;++i)
    {
        int x,y;
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        if(b[sum(x,y)]==true) --i,--q;
        b[sum(x,y)]=true;
    }
    for(int i=1;i&lt;=m;++i)
    {
        for(int j=1;j&lt;=n;++j)
        {
            if(b[sum(i,j)]==true) continue;
            if(i&amp;1)
            {
                road(s1,sum(i,j),1);
                road(sum(i,j),s1,0);
                for(int k=0;k&lt;=7;++k)
                {
                    if(check(i+dx[k],j+dy[k]))
                    {
                        road(sum(i,j),sum(i+dx[k],j+dy[k]),1e18);
                        road(sum(i+dx[k],j+dy[k]),sum(i,j),0);
                    }
                }
            }
            else
            {
                road(sum(i,j),s2,1);
                road(s2,sum(i,j),0);
            }
        }
    }
    ll r=0;
    while(bfs())
    {
        for(int i=1;i&lt;=s2;++i) t0[i]=t[i];
        r+=dfs(s1,1e18);
    }
    printf(&quot;%lld&quot;,m*n-q-r);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4304 [TJOI2013]攻击装置]]></title>
        <id>https://2745518585.github.io/post/solution-P4304/</id>
        <link href="https://2745518585.github.io/post/solution-P4304/">
        </link>
        <updated>2022-04-17T03:50:07.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P4304">P4304 [TJOI2013]攻击装置</a></p>
<h2 id="分析">分析</h2>
<p>  同 P3355，双倍经验。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const int N=50001,M=2000001;
int n,m,p=1,s1,s2,t[N],t0[N],f[N];
short dx[8]={-2,-1,1,2,2,1,-1,-2},dy[8]={-1,-2,-2,-1,1,2,2,1};
struct str
{
    int m,q;
    ll r;
}a[M];
bool check(int x,int y)
{
    return x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=n;
}
int sum(int x,int y)
{
    return (x-1)*n+y;
}
void road(int x,int y,ll r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
bool bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s1);
    for(int i=1;i&lt;=s2;++i) f[i]=0;
    f[s1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].r!=0)
            {
                f[a[i].m]=f[k]+1;
                Q.push(a[i].m);
            }
        }
    }
    return f[s2]!=0;
}
ll dfs(int x,ll r)
{
    if(x==s2) return r;
    ll s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(f[a[i].m]==f[x]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
            else f[a[i].m]=0;
            if(r==0) return s; 
        }
    }
    return s;
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    s1=n*n+1;
    s2=n*n+2;
    for(int i=1;i&lt;=n;++i)
    {
        scanf(&quot;\n&quot;);
        for(int j=1;j&lt;=n;++j)
        {
            char c=getchar();
            if(c=='1') continue;
            ++m;
            if((i+j)&amp;1)
            {
                road(s1,sum(i,j),1);
                road(sum(i,j),s1,0);
                for(int k=0;k&lt;=7;++k)
                {
                    if(check(i+dx[k],j+dy[k]))
                    {
                        road(sum(i,j),sum(i+dx[k],j+dy[k]),1e18);
                        road(sum(i+dx[k],j+dy[k]),sum(i,j),0);
                    }
                }
            }
            else
            {
                road(sum(i,j),s2,1);
                road(s2,sum(i,j),0);
            }
        }
    }
    ll r=0;
    while(bfs())
    {
        for(int i=1;i&lt;=s2;++i) t0[i]=t[i];
        r+=dfs(s1,1e18);
    }
    printf(&quot;%lld&quot;,m-r);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3355 骑士共存问题]]></title>
        <id>https://2745518585.github.io/post/solution-P3355/</id>
        <link href="https://2745518585.github.io/post/solution-P3355/">
        </link>
        <updated>2022-04-17T03:42:36.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P3355">P3355 骑士共存问题</a></p>
<h2 id="分析">分析</h2>
<p>  这道题和 P2774 是一个类型的题，只是分组方式不同。我们来看两个互相攻击的点有什么特点：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>⇔</mo><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y) \Leftrightarrow (x+1,y+2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>⇔</mo><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y) \Leftrightarrow (x-1,y+2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>⇔</mo><mo>(</mo><mi>x</mi><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y) \Leftrightarrow (x-2,y+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span>。不难发现，两个相互攻击的点横纵坐标之和奇偶性不同，我们就可以通过横纵坐标的奇偶性来分组。这道题还多了障碍物的限制，只要有障碍物的点不向外连边即可。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const int N=50001,M=2000001;
int n,m,p=1,s1,s2,t[N],t0[N],f[N];
short dx[8]={-2,-1,1,2,2,1,-1,-2},dy[8]={-1,-2,-2,-1,1,2,2,1};
bool b[201][201];
struct str
{
    int m,q;
    ll r;
}a[M];
bool check(int x,int y)
{
    return x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=n;
}
int sum(int x,int y)
{
    return (x-1)*n+y;
}
void road(int x,int y,ll r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
bool bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s1);
    for(int i=1;i&lt;=s2;++i) f[i]=0;
    f[s1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].r!=0)
            {
                f[a[i].m]=f[k]+1;
                Q.push(a[i].m);
            }
        }
    }
    return f[s2]!=0;
}
ll dfs(int x,ll r)
{
    if(x==s2) return r;
    ll s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(f[a[i].m]==f[x]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
            else f[a[i].m]=0;
            if(r==0) return s; 
        }
    }
    return s;
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    s1=n*n+1;
    s2=n*n+2;
    for(int i=1;i&lt;=m;++i)
    {
        int x,y;
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        b[x][y]=true;
    }
    for(int i=1;i&lt;=n;++i)
    {
        for(int j=1;j&lt;=n;++j)
        {
            if(b[i][j]==true) continue;
            if((i+j)&amp;1)
            {
                road(s1,sum(i,j),1);
                road(sum(i,j),s1,0);
                for(int k=0;k&lt;=7;++k)
                {
                    if(check(i+dx[k],j+dy[k]))
                    {
                        road(sum(i,j),sum(i+dx[k],j+dy[k]),1e18);
                        road(sum(i+dx[k],j+dy[k]),sum(i,j),0);
                    }
                }
            }
            else
            {
                road(sum(i,j),s2,1);
                road(s2,sum(i,j),0);
            }
        }
    }
    ll r=0;
    while(bfs())
    {
        for(int i=1;i&lt;=s2;++i) t0[i]=t[i];
        r+=dfs(s1,1e18);
    }
    printf(&quot;%lld&quot;,n*n-m-r);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2774 方格取数问题]]></title>
        <id>https://2745518585.github.io/post/solution-P2774/</id>
        <link href="https://2745518585.github.io/post/solution-P2774/">
        </link>
        <updated>2022-04-17T03:25:18.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P2774">P2774 方格取数问题</a></p>
<h2 id="分析">分析</h2>
<p>  这实际上也是一道网络流的问题，但是和以前做的题都不一样，同时也很难想到怎么做。题目中要求任意两个相邻的方格不能同时取，如果我们把一个方格放在 A 组，另一个方块放在 B 组，那么所有和 A 中方格相邻的方格都要放在 B 组，和 B 中方格相邻的都要放在 A 组。我们可以发现，统一组中方格横纵坐标的和奇偶性相同，这样我们就可以直接分组了。于是我们就把这个图分成了两组，只有两组之间有关系，同一组的方格没有关系，是不是很像二分图？我们把所有相邻的方格都用一条边连上，问题转换为删去一些节点，使得两组之间连通，求出删去节点权值的最小值。<br>
  于是我们又可以自然而然地想到最小割（最小割=最大流），但是最小割删去的是边，而不是点。我们转化一下，将源点和 A 组所有点相连，汇点和 B 组所有点相连，容量均为该点对应的数，这样删去一条边的代价刚好是对应点的数值。但是我们不能删去两组之间的边，为了不删去这些边，把这些边的容量设为正无穷，就永远不可能删去这些边了。由于最小割 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span></span></span> 最大流，所以我们只需要跑一遍最大流即可。注意只能由 A 组连向 B 组或 B 组连向 A 组，不能同时连。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const int N=10001,M=1000001;
int n,m,p=1,s1,s2,t[N],t0[N],f[N];
ll q;
struct str
{
    int m,q;
    ll r;
}a[M];
void road(int x,int y,ll r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
bool bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s1);
    for(int i=1;i&lt;=s2;++i) f[i]=0;
    f[s1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].r!=0)
            {
                f[a[i].m]=f[k]+1;
                Q.push(a[i].m);
            }
        }
    }
    return f[s2]!=0;
}
ll dfs(int x,ll r)
{
    if(x==s2) return r;
    ll s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(f[a[i].m]==f[x]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
            else f[a[i].m]=0;
            if(r==0) return s; 
        }
    }
    return s;
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
    s1=m*n+1;
    s2=m*n+2;
    for(int i=1;i&lt;=m;++i)
    {
        for(int j=1;j&lt;=n;++j)
        {
            int r;
            scanf(&quot;%d&quot;,&amp;r);
            q+=r;
            if((i+j)&amp;1)
            {
                road(s1,(i-1)*n+j,r);
                road((i-1)*n+j,s1,0);
                if(i!=1)
                {
                    road((i-1)*n+j,(i-2)*n+j,1e18);
                    road((i-2)*n+j,(i-1)*n+j,0);
                }
                if(j!=1)
                {
                    road((i-1)*n+j,(i-1)*n+j-1,1e18);
                    road((i-1)*n+j-1,(i-1)*n+j,0);
                }
                if(i!=m)
                {
                    road((i-1)*n+j,i*n+j,1e18);
                    road(i*n+j,(i-1)*n+j,0);
                }
                if(j!=n)
                {
                    road((i-1)*n+j,(i-1)*n+j+1,1e18);
                    road((i-1)*n+j+1,(i-1)*n+j,0);
                }
            }
            else
            {
                road((i-1)*n+j,s2,r);
                road(s2,(i-1)*n+j,0);
            }
        }
    }
    ll r=0;
    while(bfs())
    {
        for(int i=1;i&lt;=s2;++i) t0[i]=t[i];
        r+=dfs(s1,1e18);
    }
    printf(&quot;%lld&quot;,q-r);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2472 [SCOI2007] 蜥蜴]]></title>
        <id>https://2745518585.github.io/post/solution-P2472/</id>
        <link href="https://2745518585.github.io/post/solution-P2472/">
        </link>
        <updated>2022-04-16T11:39:42.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P2472">P2472 [SCOI2007] 蜥蜴</a></p>
<h2 id="分析">分析</h2>
<p>  这道题同样也要拆点，每个点最多能经过的蜥蜴数就是它的高度，拆点后中间边的流量设为这个石柱的高度即可。剩下的就枚举两个合法石柱并建边，把源点和有蜥蜴的点相连，容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，把能跳出地图的点与汇点相连。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int m,n,N,d,o,p=1,s1,s2,t[10001],t0[10001],f[10001];
struct str
{
    int m,q,r;
}a[1000001];
void road(int x,int y,int r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
bool bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s1);
    for(int i=1;i&lt;=N;++i) f[i]=0;
    f[s1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].r!=0)
            {
                f[a[i].m]=f[k]+1;
                Q.push(a[i].m);
            }
        }
    }
    return f[s2]!=0;
}
int dfs(int x,int r)
{
    if(x==s2) return r;
    int s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(f[a[i].m]==f[x]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
            else f[a[i].m]=0;
            if(r==0) return s; 
        }
    }
    return s;
}
int main()
{
    scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;d);
    N=m*n*2+2;
    s1=N-1;
    s2=N;
    for(int i=1;i&lt;=m;++i)
    {
        scanf(&quot;\n&quot;);
        for(int j=1;j&lt;=n;++j)
        {
            int r=getchar()-'0';
            if(r!=0)
            {
                int a1=(i-1)*n+j;
                road(a1+m*n,a1,r);
                road(a1,a1+m*n,0);
            }
        }
    }
    for(int i=1;i&lt;=m;++i)
    {
        scanf(&quot;\n&quot;);
        for(int j=1;j&lt;=n;++j)
        {
            char z=getchar();
            if(z=='L')
            {
                ++o;
                int a1=(i-1)*n+j;
                road(s1,a1+m*n,1);
                road(a1+m*n,s1,0);
            }
        }
    }
    for(int i=1;i&lt;=m;++i)
    {
        for(int j=1;j&lt;=n;++j)
        {
            if(i&lt;=d||i&gt;=m-d+1||j&lt;=d||j&gt;=n-d+1)
            {
                int a1=(i-1)*n+j;
                road(a1,s2,1e9);
                road(s2,a1,0);
            }
        }
    }
    for(int i=1;i&lt;=m;++i)
    {
        for(int j=1;j&lt;=n;++j)
        {
            int a1=(i-1)*n+j;
            for(int k=1;k&lt;=m;++k)
            {
                for(int l=1;l&lt;=n;++l)
                {
                    int a2=(k-1)*n+l;
                    if((i-k)*(i-k)+(j-l)*(j-l)&lt;=d*d)
                    {
                        road(a1,a2+m*n,1e9);
                        road(a2+m*n,a1,0);
                    }
                }
            }
        }
    }
    int r=0;
    while(bfs())
    {
        for(int i=1;i&lt;=N;++i) t0[i]=t[i];
        r+=dfs(s1,1e9);
    }
    printf(&quot;%d&quot;,o-r);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1402 酒店之王]]></title>
        <id>https://2745518585.github.io/post/solution-P1402/</id>
        <link href="https://2745518585.github.io/post/solution-P1402/">
        </link>
        <updated>2022-04-16T11:30:44.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P1402">P1402 酒店之王</a></p>
<h2 id="分析">分析</h2>
<p>  这道题也是一道需要拆点的题，和 P1231 一样，这里不再赘述。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int n,n1,n2,n3,p=1,s1,s2,t[10001],f[10001];
struct str
{
    int m,q,r;
}a[1000001];
void road(int x,int y,int r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
bool bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s1);
    for(int i=1;i&lt;=n;++i) f[i]=0;
    f[s1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].r!=0)
            {
                f[a[i].m]=f[k]+1;
                Q.push(a[i].m);
            }
        }
    }
    return f[s2]!=0;
}
int dfs(int x,int r)
{
    if(x==s2) return r;
    int s=0;
    for(int i=t[x];i!=0;i=a[i].q)
    {
        if(f[a[i].m]==f[x]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
        }
    }
    return s;
}
int main()
{
    scanf(&quot;%d%d%d&quot;,&amp;n1,&amp;n2,&amp;n3);
    n=n1*2+n2+n3+2;
    s1=1;
    s2=n;
    for(int i=1;i&lt;=n1;++i)
    {
        for(int j=1;j&lt;=n2;++j)
        {
            int x;
            scanf(&quot;%d&quot;,&amp;x);
            if(x==1)
            {
                road(j+n1*2+1,i+1,1);
                road(i+1,j+n1*2+1,0);
            }
        }
    }
    for(int i=1;i&lt;=n1;++i)
    {
        for(int j=1;j&lt;=n3;++j)
        {
            int x;
            scanf(&quot;%d&quot;,&amp;x);
            if(x==1)
            {
                road(i+n1+1,j+n1*2+n2+1,1);
                road(j+n1*2+n2+1,i+n1+1,0);
            }
        }
    }
    for(int i=1;i&lt;=n1;++i)
    {
        road(i+1,i+n1+1,1);
        road(i+n1+1,i+1,0);
    }
    for(int i=1;i&lt;=n2;++i)
    {
        road(1,i+n1*2+1,1);
        road(i+n1*2+1,1,0);
    }
    for(int i=1;i&lt;=n3;++i)
    {
        road(i+n1*2+n2+1,n,1);
        road(n,i+n1*2+n2+1,0);
    }
    int r=0;
    while(bfs())
    {
        r+=dfs(s1,1e9);
    }
    printf(&quot;%d&quot;,r);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1231 教辅的组成]]></title>
        <id>https://2745518585.github.io/post/solution-P1231/</id>
        <link href="https://2745518585.github.io/post/solution-P1231/">
        </link>
        <updated>2022-04-16T11:14:44.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P1231">P1231 教辅的组成</a></p>
<h2 id="分析">分析</h2>
<p>  这道题咋一看非常简单，只需要将书和练习册、答案的对应关系转换成边，每条边容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，规定一个顺序：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>源点</mtext><mo>→</mo><mtext>练习册</mtext><mo>→</mo><mtext>书</mtext><mo>→</mo><mtext>答案</mtext><mo>→</mo><mtext>汇点</mtext></mrow><annotation encoding="application/x-tex">\text{源点} \rightarrow \text{练习册} \rightarrow \text{书}\rightarrow \text{答案} \rightarrow \text{汇点}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">源点</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">练习册</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">书</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">答案</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">汇点</span></span></span></span></span>。但是我们发现，如果简单地按照上面这种方式建图，可能有多于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的流量流过一本书，也就是这本书被选了两次，这是不允许的。如何解决？这就要用到最大流的一个经典思想：拆点。<br>
<img src="https://2745518585.github.io/post-images/1650084681672.png" alt="1" width="400" loading="lazy"><br>
  拆点的思想就是把一个点拆成两个点，其中入边全部连在一个点，出边连在另一个点，并把两个点用容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的边相连，这样就可以保证流过每个点的流量最多为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。将这个思想加入到上面建的图中，就可以解决这个问题了。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int n,n1,n2,n3,m1,m2,p=1,s1,s2,t[10001],f[10001];
struct str
{
    int m,q,r;
}a[1000001];
void road(int x,int y,int r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
bool bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s1);
    for(int i=1;i&lt;=n;++i) f[i]=0;
    f[s1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].r!=0)
            {
                f[a[i].m]=f[k]+1;
                Q.push(a[i].m);
            }
        }
    }
    return f[s2]!=0;
}
int dfs(int x,int r)
{
    if(x==s2) return r;
    int s=0;
    for(int i=t[x];i!=0;i=a[i].q)
    {
        if(f[a[i].m]==f[x]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
        }
    }
    return s;
}
int main()
{
    scanf(&quot;%d%d%d%d&quot;,&amp;n1,&amp;n2,&amp;n3,&amp;m1);
    n=n1*2+n2+n3+2;
    s1=1;
    s2=n;
    for(int i=1;i&lt;=m1;++i)
    {
        int x,y;
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        road(y+n1*2+1,x+1,1);
        road(x+1,y+n1*2+1,0);
    }
    scanf(&quot;%d&quot;,&amp;m2);
    for(int i=1;i&lt;=m2;++i)
    {
        int x,y;
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        road(x+n1+1,y+n1*2+n2+1,1);
        road(y+n1*2+n2+1,x+n1+1,0);
    }
    for(int i=1;i&lt;=n1;++i)
    {
        road(i+1,i+n1+1,1);
        road(i+n1+1,i+1,0);
    }
    for(int i=1;i&lt;=n2;++i)
    {
        road(1,i+n1*2+1,1);
        road(i+n1*2+1,1,0);
    }
    for(int i=1;i&lt;=n3;++i)
    {
        road(i+n1*2+n2+1,n,1);
        road(n,i+n1*2+n2+1,0);
    }
    int r=0;
    while(bfs())
    {
        r+=dfs(s1,1e9);
    }
    printf(&quot;%d&quot;,r);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最大流题单]]></title>
        <id>https://2745518585.github.io/post/maximum-flow-problemlist/</id>
        <link href="https://2745518585.github.io/post/maximum-flow-problemlist/">
        </link>
        <updated>2022-04-16T11:02:26.000Z</updated>
        <content type="html"><![CDATA[<p>  这是 <a href="https://2745518585.github.io/post/maximum-flow-Dinic">最大流</a> 的几道经典题目，建议按照顺序来做。</p>
<p>  <a href="https://2745518585.github.io/post/P2740-solution">P2740 [USACO4.2]草地排水Drainage Ditches</a></p>
<p>  <a href="https://2745518585.github.io/post/P1343-solution">P1343 地震逃生</a></p>
<p>  <a href="https://2745518585.github.io/post/P2936-solution">P2936 [USACO09JAN]Total Flow S</a></p>
<p>  <a href="https://2745518585.github.io/post/P3254-solution">P3254 圆桌问题</a></p>
<p>  <a href="https://2745518585.github.io/post/P2763-solution">P2763 试题库问题</a></p>
<p>  <a href="https://2745518585.github.io/post/P2754-solution">P2754 [CTSC1999]家园 / 星际转移问题</a></p>
<p>  <a href="https://2745518585.github.io/post/P1231-solution">P1231 教辅的组成</a></p>
<p>  <a href="https://2745518585.github.io/post/P1402-solution">P1402 酒店之王</a></p>
<p>  <a href="https://2745518585.github.io/post/P2472-solution">P2472 [SCOI2007] 蜥蜴</a></p>
<p>  <a href="https://2745518585.github.io/post/P2774-solution">P2774 方格取数问题</a></p>
<p>  <a href="https://2745518585.github.io/post/P3355-solution">P3355 骑士共存问题</a></p>
<p>  <a href="https://2745518585.github.io/post/P4304-solution">P4304 [TJOI2013]攻击装置</a></p>
<p>  <a href="https://2745518585.github.io/post/P5030-solution">P5030 长脖子鹿放置</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2754 [CTSC1999]家园 / 星际转移问题]]></title>
        <id>https://2745518585.github.io/post/solution-P2754/</id>
        <link href="https://2745518585.github.io/post/solution-P2754/">
        </link>
        <updated>2022-04-16T10:36:23.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P2754">P2754 [CTSC1999]家园 / 星际转移问题</a></p>
<h2 id="分析">分析</h2>
<p>  这道题其实也可以用网络流来做，每一个太空站（地球、月球）在每个时间都建一个点。由于人可以在太空站上停留，所以每一个点都要向下一个时间的对应点连边，容量为正无穷。对于每个太空船将当前时间的起点和终点连接起来，容量为太空船的承载能力。建出来的图如下：<br>
<img src="https://2745518585.github.io/post-images/1650106165513.png" alt="1" loading="lazy"><br>
  （图片来自网络）<br>
  但是我们只能在确定时间的情况下求出最多的转移人数，无法直接求出最少天数，必须二分。但是还有另一个方法，假设我们已经跑了时间在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 以内的图，得到了最大流和残留网络，如果我们加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时间的点和边，再在残留网络上跑最大流，将得到的最大流加在原来的最大流上，是不是就可以得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 天的转移人数了？因为这相当于我们已经找到了一些増广路，继续寻找更多増广路的过程。这样我们跑出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1\sim m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 时间的最大转移人数，只相当于跑了一遍时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的图上的最大流。对于无解情况，我们只需要选一个比较大的数，如果都跑不出来就判无解即可。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int N,M=200,n,m,q,p=1,s1,s2,t[10001],t0[10001],f[10001],e[201][501],y[501],z[501];
bool u=true;
struct str
{
    int m,q;
    int r;
}a[1000001];
void road(int x,int y,int r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
bool bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s1);
    for(int i=1;i&lt;=N;++i) f[i]=0;
    f[s1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].r!=0)
            {
                f[a[i].m]=f[k]+1;
                Q.push(a[i].m);
            }
        }
    }
    return f[s2]!=0;
}
int dfs(int x,int r)
{
    if(x==s2) return r;
    int s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(f[a[i].m]==f[x]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
            else f[a[i].m]=0;
            if(r==0) return s; 
        }
    }
    return s;
}
int main()
{
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);
    n+=2;
    for(int i=1;i&lt;=m;++i)
    {
        scanf(&quot;%d%d&quot;,&amp;z[i],&amp;y[i]);
        for(int j=0;j&lt;=y[i]-1;++j)
        {
            scanf(&quot;%d&quot;,&amp;e[i][j]);
            e[i][j]+=2;
        }
    }
    s1=2;
    int r=0;
    for(int i=1;i&lt;=M;++i)
    {
        N=(i+1)*n;
        s2=i*n+1;
        for(int j=1;j&lt;=n;++j)
        {
            road((i-1)*n+j,i*n+j,1e9);
            road(i*n+j,(i-1)*n+j,0);
        }
        for(int j=1;j&lt;=m;++j)
        {
            road((i-1)*n+e[j][(i-1)%y[j]],i*n+e[j][i%y[j]],z[j]);
            road(i*n+e[j][i%y[j]],(i-1)*n+e[j][(i-1)%y[j]],0);
        }
        while(bfs())
        {
            for(int j=1;j&lt;=N;++j) t0[j]=t[j];
            r+=dfs(s1,1e9);
        }
        if(r&gt;=q)
        {
            printf(&quot;%d&quot;,i);
            return 0;
        }
    }
    printf(&quot;0&quot;);
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2763 试题库问题]]></title>
        <id>https://2745518585.github.io/post/solution-P2763/</id>
        <link href="https://2745518585.github.io/post/solution-P2763/">
        </link>
        <updated>2022-04-16T04:34:23.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P2763">P2763 试题库问题</a></p>
<h2 id="分析">分析</h2>
<p>  一道网络流问题，我们把每道题和所属类型相连，容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，再将源点和每道题相连，容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，汇点和每个类型相连，容量为地 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个类型的题数，如果跑出来的最大流和总题数相同，表示每个类型都有足够的题数，也就是有一个合法方案。<br>
  在跑完网络流后，要输出结果，我们可以观察残留网络。一条边有流量流过，表示这条边起点表示的题目被作为这条边终点表示的类型选中了。对于每个类型，找到它的出边，如果有剩余容量，表示其反向边有流量流过。当然每个类型的出边还有到汇点的边，但是这条边一定没有剩余容量，不用考虑。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
int n,m,q=0,N,p=1,s1,s2,t[10001],t0[10001],f[10001],g[10001];
bool u=true;
struct str
{
    int m,q;
    ll r;
}a[1000001];
void road(int x,int y,ll r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
void bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s2);
    f[s2]=1;
    g[1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0)
            {
                f[a[i].m]=f[k]+1;
                ++g[f[a[i].m]];
                Q.push(a[i].m);
            }
        }
    }
}
ll dfs(int x,ll r)
{
    if(x==s2) return r;
    ll s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(f[x]==f[a[i].m]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
            if(r==0) return s;
        }
    }
    --g[f[x]];
    if(g[f[x]]==0) u=false;
    ++f[x];
    ++g[f[x]];
    return s;
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    N=n+m+2;
    s1=N-1;
    s2=N;
    for(int i=1;i&lt;=m;++i)
    {
        road(s1,i,1);
        road(i,s1,0);
    }
    for(int i=1;i&lt;=n;++i)
    {
        ll r;
        scanf(&quot;%lld&quot;,&amp;r);
        q+=r;
        road(m+i,s2,r);
        road(s2,m+i,0);
    }
    for(int i=1;i&lt;=m;++i)
    {
        int d;
        scanf(&quot;%d&quot;,&amp;d);
        for(int j=1;j&lt;=d;++j)
        {
            int x;
            scanf(&quot;%d&quot;,&amp;x);
            road(i,m+x,1);
            road(m+x,i,0);
        }
    }
    bfs();
    ll r=0;
    while(u==true)
    {
        for(int i=1;i&lt;=N;++i) t0[i]=t[i];
        r+=dfs(s1,1e18);
    }
    if(r&lt;q)
    {
        printf(&quot;No Solution!&quot;);
        return 0;
    }
    for(int i=1;i&lt;=n;++i)
    {
        printf(&quot;%d:&quot;,i);
        for(int j=t[m+i];j!=0;j=a[j].q)
        {
            if(a[j].r==1)
            {
                printf(&quot; %d&quot;,a[j].m);
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>