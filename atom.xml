<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2745518585.github.io</id>
    <title>赵悦岑&apos;s Blog</title>
    <updated>2022-04-16T12:15:23.456Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2745518585.github.io"/>
    <link rel="self" href="https://2745518585.github.io/atom.xml"/>
    <subtitle>好好刷题，天天向上！</subtitle>
    <logo>https://2745518585.github.io/images/avatar.png</logo>
    <icon>https://2745518585.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 赵悦岑&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[P2472 [SCOI2007] 蜥蜴]]></title>
        <id>https://2745518585.github.io/post/solution-P2472/</id>
        <link href="https://2745518585.github.io/post/solution-P2472/">
        </link>
        <updated>2022-04-16T11:39:42.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P2472">P2472 [SCOI2007] 蜥蜴</a></p>
<h2 id="分析">分析</h2>
<p>  这道题同样也要拆点，每个点最多能经过的蜥蜴数就是它的高度，拆点后中间边的流量设为这个石柱的高度即可。剩下的就枚举两个合法石柱并建边，把源点和有蜥蜴的点相连，容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，把能跳出地图的点与汇点相连。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int m,n,N,d,o,p=1,s1,s2,t[10001],t0[10001],f[10001];
struct str
{
    int m,q,r;
}a[1000001];
void road(int x,int y,int r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
bool bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s1);
    for(int i=1;i&lt;=N;++i) f[i]=0;
    f[s1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].r!=0)
            {
                f[a[i].m]=f[k]+1;
                Q.push(a[i].m);
            }
        }
    }
    return f[s2]!=0;
}
int dfs(int x,int r)
{
    if(x==s2) return r;
    int s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(f[a[i].m]==f[x]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
            else f[a[i].m]=0;
            if(r==0) return s; 
        }
    }
    return s;
}
int main()
{
    scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;d);
    N=m*n*2+2;
    s1=N-1;
    s2=N;
    for(int i=1;i&lt;=m;++i)
    {
        scanf(&quot;\n&quot;);
        for(int j=1;j&lt;=n;++j)
        {
            int r=getchar()-'0';
            if(r!=0)
            {
                int a1=(i-1)*n+j;
                road(a1+m*n,a1,r);
                road(a1,a1+m*n,0);
            }
        }
    }
    for(int i=1;i&lt;=m;++i)
    {
        scanf(&quot;\n&quot;);
        for(int j=1;j&lt;=n;++j)
        {
            char z=getchar();
            if(z=='L')
            {
                ++o;
                int a1=(i-1)*n+j;
                road(s1,a1+m*n,1);
                road(a1+m*n,s1,0);
            }
        }
    }
    for(int i=1;i&lt;=m;++i)
    {
        for(int j=1;j&lt;=n;++j)
        {
            if(i&lt;=d||i&gt;=m-d+1||j&lt;=d||j&gt;=n-d+1)
            {
                int a1=(i-1)*n+j;
                road(a1,s2,1e9);
                road(s2,a1,0);
            }
        }
    }
    for(int i=1;i&lt;=m;++i)
    {
        for(int j=1;j&lt;=n;++j)
        {
            int a1=(i-1)*n+j;
            for(int k=1;k&lt;=m;++k)
            {
                for(int l=1;l&lt;=n;++l)
                {
                    int a2=(k-1)*n+l;
                    if((i-k)*(i-k)+(j-l)*(j-l)&lt;=d*d)
                    {
                        road(a1,a2+m*n,1e9);
                        road(a2+m*n,a1,0);
                    }
                }
            }
        }
    }
    int r=0;
    while(bfs())
    {
        for(int i=1;i&lt;=N;++i) t0[i]=t[i];
        r+=dfs(s1,1e9);
    }
    printf(&quot;%d&quot;,o-r);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1402 酒店之王]]></title>
        <id>https://2745518585.github.io/post/solution-P1402/</id>
        <link href="https://2745518585.github.io/post/solution-P1402/">
        </link>
        <updated>2022-04-16T11:30:44.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P1402">P1402 酒店之王</a></p>
<h2 id="分析">分析</h2>
<p>  这道题也是一道需要拆点的题，和 P1231 一样，这里不再赘述。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int n,n1,n2,n3,p=1,s1,s2,t[10001],f[10001];
struct str
{
    int m,q,r;
}a[1000001];
void road(int x,int y,int r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
bool bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s1);
    for(int i=1;i&lt;=n;++i) f[i]=0;
    f[s1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].r!=0)
            {
                f[a[i].m]=f[k]+1;
                Q.push(a[i].m);
            }
        }
    }
    return f[s2]!=0;
}
int dfs(int x,int r)
{
    if(x==s2) return r;
    int s=0;
    for(int i=t[x];i!=0;i=a[i].q)
    {
        if(f[a[i].m]==f[x]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
        }
    }
    return s;
}
int main()
{
    scanf(&quot;%d%d%d&quot;,&amp;n1,&amp;n2,&amp;n3);
    n=n1*2+n2+n3+2;
    s1=1;
    s2=n;
    for(int i=1;i&lt;=n1;++i)
    {
        for(int j=1;j&lt;=n2;++j)
        {
            int x;
            scanf(&quot;%d&quot;,&amp;x);
            if(x==1)
            {
                road(j+n1*2+1,i+1,1);
                road(i+1,j+n1*2+1,0);
            }
        }
    }
    for(int i=1;i&lt;=n1;++i)
    {
        for(int j=1;j&lt;=n3;++j)
        {
            int x;
            scanf(&quot;%d&quot;,&amp;x);
            if(x==1)
            {
                road(i+n1+1,j+n1*2+n2+1,1);
                road(j+n1*2+n2+1,i+n1+1,0);
            }
        }
    }
    for(int i=1;i&lt;=n1;++i)
    {
        road(i+1,i+n1+1,1);
        road(i+n1+1,i+1,0);
    }
    for(int i=1;i&lt;=n2;++i)
    {
        road(1,i+n1*2+1,1);
        road(i+n1*2+1,1,0);
    }
    for(int i=1;i&lt;=n3;++i)
    {
        road(i+n1*2+n2+1,n,1);
        road(n,i+n1*2+n2+1,0);
    }
    int r=0;
    while(bfs())
    {
        r+=dfs(s1,1e9);
    }
    printf(&quot;%d&quot;,r);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1231 教辅的组成]]></title>
        <id>https://2745518585.github.io/post/solution-P1231/</id>
        <link href="https://2745518585.github.io/post/solution-P1231/">
        </link>
        <updated>2022-04-16T11:14:44.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P1231">P1231 教辅的组成</a></p>
<h2 id="分析">分析</h2>
<p>  这道题咋一看非常简单，只需要将书和练习册、答案的对应关系转换成边，每条边容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，规定一个顺序：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>源点</mtext><mo>→</mo><mtext>练习册</mtext><mo>→</mo><mtext>书</mtext><mo>→</mo><mtext>答案</mtext><mo>→</mo><mtext>汇点</mtext></mrow><annotation encoding="application/x-tex">\text{源点} \rightarrow \text{练习册} \rightarrow \text{书}\rightarrow \text{答案} \rightarrow \text{汇点}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">源点</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">练习册</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">书</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">答案</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">汇点</span></span></span></span></span>。但是我们发现，如果简单地按照上面这种方式建图，可能有多于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的流量流过一本书，也就是这本书被选了两次，这是不允许的。如何解决？这就要用到最大流的一个经典思想：拆点。<br>
<img src="https://2745518585.github.io/post-images/1650084681672.png" alt="1" width="400" loading="lazy"><br>
  拆点的思想就是把一个点拆成两个点，其中入边全部连在一个点，出边连在另一个点，并把两个点用容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的边相连，这样就可以保证流过每个点的流量最多为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。将这个思想加入到上面建的图中，就可以解决这个问题了。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int n,n1,n2,n3,m1,m2,p=1,s1,s2,t[10001],f[10001];
struct str
{
    int m,q,r;
}a[1000001];
void road(int x,int y,int r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
bool bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s1);
    for(int i=1;i&lt;=n;++i) f[i]=0;
    f[s1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].r!=0)
            {
                f[a[i].m]=f[k]+1;
                Q.push(a[i].m);
            }
        }
    }
    return f[s2]!=0;
}
int dfs(int x,int r)
{
    if(x==s2) return r;
    int s=0;
    for(int i=t[x];i!=0;i=a[i].q)
    {
        if(f[a[i].m]==f[x]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
        }
    }
    return s;
}
int main()
{
    scanf(&quot;%d%d%d%d&quot;,&amp;n1,&amp;n2,&amp;n3,&amp;m1);
    n=n1*2+n2+n3+2;
    s1=1;
    s2=n;
    for(int i=1;i&lt;=m1;++i)
    {
        int x,y;
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        road(y+n1*2+1,x+1,1);
        road(x+1,y+n1*2+1,0);
    }
    scanf(&quot;%d&quot;,&amp;m2);
    for(int i=1;i&lt;=m2;++i)
    {
        int x,y;
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        road(x+n1+1,y+n1*2+n2+1,1);
        road(y+n1*2+n2+1,x+n1+1,0);
    }
    for(int i=1;i&lt;=n1;++i)
    {
        road(i+1,i+n1+1,1);
        road(i+n1+1,i+1,0);
    }
    for(int i=1;i&lt;=n2;++i)
    {
        road(1,i+n1*2+1,1);
        road(i+n1*2+1,1,0);
    }
    for(int i=1;i&lt;=n3;++i)
    {
        road(i+n1*2+n2+1,n,1);
        road(n,i+n1*2+n2+1,0);
    }
    int r=0;
    while(bfs())
    {
        r+=dfs(s1,1e9);
    }
    printf(&quot;%d&quot;,r);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最大流题单]]></title>
        <id>https://2745518585.github.io/post/maximum-flow-Dinic-problemlist/</id>
        <link href="https://2745518585.github.io/post/maximum-flow-Dinic-problemlist/">
        </link>
        <updated>2022-04-16T11:02:26.000Z</updated>
        <content type="html"><![CDATA[<p>  这是 <a href="https://2745518585.github.io/post/maximum-flow-Dinic">最大流</a> 的几道经典题目，建议按照顺序来做。</p>
<p>  <a href="https://2745518585.github.io/post/P2740-solution">P2740 [USACO4.2]草地排水Drainage Ditches</a></p>
<p>  <a href="https://2745518585.github.io/post/P1343-solution">P1343 地震逃生</a></p>
<p>  <a href="https://2745518585.github.io/post/P2936-solution">P2936 [USACO09JAN]Total Flow S</a></p>
<p>  <a href="https://2745518585.github.io/post/P3254-solution">P3254 圆桌问题</a></p>
<p>  <a href="https://2745518585.github.io/post/P2763-solution">P2763 试题库问题</a></p>
<p>  [P2754 [CTSC1999]家园 / 星际转移问题]](https://2745518585.github.io/post/P2754-solution)</p>
<p>  <a href="https://2745518585.github.io/post/P1231-solution">P1231 教辅的组成</a></p>
<p>  <a href="https://2745518585.github.io/post/P1402-solution">P1402 酒店之王</a></p>
<p>  <a href="https://2745518585.github.io/post/P2472-solution">P2472 [SCOI2007] 蜥蜴</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2754 [CTSC1999]家园 / 星际转移问题]]></title>
        <id>https://2745518585.github.io/post/solution-P2754/</id>
        <link href="https://2745518585.github.io/post/solution-P2754/">
        </link>
        <updated>2022-04-16T10:36:23.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P2754">P2754 [CTSC1999]家园 / 星际转移问题</a></p>
<h2 id="分析">分析</h2>
<p>  这道题其实也可以用网络流来做，每一个太空站（地球、月球）在每个时间都建一个点。由于人可以在太空站上停留，所以每一个点都要向下一个时间的对应点连边，容量为正无穷。对于每个太空船将当前时间的起点和终点连接起来，容量为太空船的承载能力。建出来的图如下：<br>
<img src="https://2745518585.github.io/post-images/1650106165513.png" alt="1" loading="lazy"><br>
  （图片来自网络）<br>
  但是我们只能在确定时间的情况下求出最多的转移人数，无法直接求出最少天数，必须二分。但是还有另一个方法，假设我们已经跑了时间在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 以内的图，得到了最大流和残留网络，如果我们加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时间的点和边，再在残留网络上跑最大流，将得到的最大流加在原来的最大流上，是不是就可以得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 天的转移人数了？因为这相当于我们已经找到了一些増广路，继续寻找更多増广路的过程。这样我们跑出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1\sim m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 时间的最大转移人数，只相当于跑了一遍时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的图上的最大流。对于无解情况，我们只需要选一个比较大的数，如果都跑不出来就判无解即可。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int N,M=200,n,m,q,p=1,s1,s2,t[10001],t0[10001],f[10001],e[201][501],y[501],z[501];
bool u=true;
struct str
{
    int m,q;
    int r;
}a[1000001];
void road(int x,int y,int r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
bool bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s1);
    for(int i=1;i&lt;=N;++i) f[i]=0;
    f[s1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].r!=0)
            {
                f[a[i].m]=f[k]+1;
                Q.push(a[i].m);
            }
        }
    }
    return f[s2]!=0;
}
int dfs(int x,int r)
{
    if(x==s2) return r;
    int s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(f[a[i].m]==f[x]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
            else f[a[i].m]=0;
            if(r==0) return s; 
        }
    }
    return s;
}
int main()
{
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);
    n+=2;
    for(int i=1;i&lt;=m;++i)
    {
        scanf(&quot;%d%d&quot;,&amp;z[i],&amp;y[i]);
        for(int j=0;j&lt;=y[i]-1;++j)
        {
            scanf(&quot;%d&quot;,&amp;e[i][j]);
            e[i][j]+=2;
        }
    }
    s1=2;
    int r=0;
    for(int i=1;i&lt;=M;++i)
    {
        N=(i+1)*n;
        s2=i*n+1;
        for(int j=1;j&lt;=n;++j)
        {
            road((i-1)*n+j,i*n+j,1e9);
            road(i*n+j,(i-1)*n+j,0);
        }
        for(int j=1;j&lt;=m;++j)
        {
            road((i-1)*n+e[j][(i-1)%y[j]],i*n+e[j][i%y[j]],z[j]);
            road(i*n+e[j][i%y[j]],(i-1)*n+e[j][(i-1)%y[j]],0);
        }
        while(bfs())
        {
            for(int j=1;j&lt;=N;++j) t0[j]=t[j];
            r+=dfs(s1,1e9);
        }
        if(r&gt;=q)
        {
            printf(&quot;%d&quot;,i);
            return 0;
        }
    }
    printf(&quot;0&quot;);
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2763 试题库问题]]></title>
        <id>https://2745518585.github.io/post/solution-P2763/</id>
        <link href="https://2745518585.github.io/post/solution-P2763/">
        </link>
        <updated>2022-04-16T04:34:23.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P2763">P2763 试题库问题</a></p>
<h2 id="分析">分析</h2>
<p>  一道网络流问题，我们把每道题和所属类型相连，容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，再将源点和每道题相连，容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，汇点和每个类型相连，容量为地 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个类型的题数，如果跑出来的最大流和总题数相同，表示每个类型都有足够的题数，也就是有一个合法方案。<br>
  在跑完网络流后，要输出结果，我们可以观察残留网络。一条边有流量流过，表示这条边起点表示的题目被作为这条边终点表示的类型选中了。对于每个类型，找到它的出边，如果有剩余容量，表示其反向边有流量流过。当然每个类型的出边还有到汇点的边，但是这条边一定没有剩余容量，不用考虑。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
int n,m,q=0,N,p=1,s1,s2,t[10001],t0[10001],f[10001],g[10001];
bool u=true;
struct str
{
    int m,q;
    ll r;
}a[1000001];
void road(int x,int y,ll r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
void bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s2);
    f[s2]=1;
    g[1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0)
            {
                f[a[i].m]=f[k]+1;
                ++g[f[a[i].m]];
                Q.push(a[i].m);
            }
        }
    }
}
ll dfs(int x,ll r)
{
    if(x==s2) return r;
    ll s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(f[x]==f[a[i].m]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
            if(r==0) return s;
        }
    }
    --g[f[x]];
    if(g[f[x]]==0) u=false;
    ++f[x];
    ++g[f[x]];
    return s;
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    N=n+m+2;
    s1=N-1;
    s2=N;
    for(int i=1;i&lt;=m;++i)
    {
        road(s1,i,1);
        road(i,s1,0);
    }
    for(int i=1;i&lt;=n;++i)
    {
        ll r;
        scanf(&quot;%lld&quot;,&amp;r);
        q+=r;
        road(m+i,s2,r);
        road(s2,m+i,0);
    }
    for(int i=1;i&lt;=m;++i)
    {
        int d;
        scanf(&quot;%d&quot;,&amp;d);
        for(int j=1;j&lt;=d;++j)
        {
            int x;
            scanf(&quot;%d&quot;,&amp;x);
            road(i,m+x,1);
            road(m+x,i,0);
        }
    }
    bfs();
    ll r=0;
    while(u==true)
    {
        for(int i=1;i&lt;=N;++i) t0[i]=t[i];
        r+=dfs(s1,1e18);
    }
    if(r&lt;q)
    {
        printf(&quot;No Solution!&quot;);
        return 0;
    }
    for(int i=1;i&lt;=n;++i)
    {
        printf(&quot;%d:&quot;,i);
        for(int j=t[m+i];j!=0;j=a[j].q)
        {
            if(a[j].r==1)
            {
                printf(&quot; %d&quot;,a[j].m);
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3254 圆桌问题]]></title>
        <id>https://2745518585.github.io/post/solution-P3254/</id>
        <link href="https://2745518585.github.io/post/solution-P3254/">
        </link>
        <updated>2022-04-13T05:51:56.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P3254">P3254 圆桌问题</a></p>
<h2 id="分析">分析</h2>
<p>  这道题也比较容易发现是一道网络流，我们来考虑如何建图。左边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个点代表每个单位，右边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个点代表每个圆桌，每一个单位在一个圆桌只能有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个人，也就是从每个单位到每个圆桌的边容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。然后将源点与每个单位相连，容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，将每个圆桌与汇点相连，容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。最后跑一边最大流，得到的最大流就是答案。<br>
  由于有很多点，初始化的时候注意要初始化全部的点。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int n,m=0,m1,m2,p=1,s1,s2,t[10001],t0[10001],f[10001],g[10001];
bool u=true;
struct str
{
    int m,q,r;
}a[1000001];
void road(int x,int y,int r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
void bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s2);
    f[s2]=1;
    g[1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].r==0)
            {
                f[a[i].m]=f[k]+1;
                ++g[f[a[i].m]];
                Q.push(a[i].m);
            }
        }
    }
}
int dfs(int x,int r)
{
    if(x==s2) return r;
    int s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(f[x]==f[a[i].m]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
            if(r==0) return s;
        }
    }
    --g[f[x]];
    if(g[f[x]]==0) u=false;
    ++f[x];
    ++g[f[x]];
    return s;
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;m1,&amp;m2);
    n=m1+m2+2;
    s1=1;
    s2=n;
    for(int i=1;i&lt;=m1;++i)
    {
        int r;
        scanf(&quot;%d&quot;,&amp;r);
        m+=r;
        road(1,i+1,r);
        road(i+1,1,0);
    }
    for(int i=1;i&lt;=m2;++i)
    {
        int r;
        scanf(&quot;%d&quot;,&amp;r);
        road(i+m1+1,n,r);
        road(n,i+m1+1,0);
    }
    for(int i=1;i&lt;=m1;++i)
    {
        for(int j=1;j&lt;=m2;++j)
        {
            road(i+1,j+m1+1,1);
            road(j+m1+1,i+1,0);
        }
    }
    bfs();
    int r=0;
    while(u==true)
    {
        for(int i=1;i&lt;=n;++i) t0[i]=t[i];
        r+=dfs(s1,1e9);
    }
    if(r!=m)
    {
        printf(&quot;0&quot;);
        return 0;
    }
    printf(&quot;1\n&quot;);
    for(int i=1;i&lt;=m1;++i)
    {
        for(int j=t[i+1];j!=0;j=a[j].q)
        {
            if(a[j].m!=1&amp;&amp;a[j].r==0)
            {
                printf(&quot;%d &quot;,a[j].m-m1-1);
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2936 [USACO09JAN]Total Flow S]]></title>
        <id>https://2745518585.github.io/post/solution-P2936/</id>
        <link href="https://2745518585.github.io/post/solution-P2936/">
        </link>
        <updated>2022-04-13T05:47:30.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P2936">P2936 [USACO09JAN]Total Flow S</a></p>
<h2 id="分析">分析</h2>
<p>  最大流的模板题，注意输入。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int m,p=1,s1,s2,t[10001],f[10001];
struct str
{
    int m,q,r;
}a[1000001];
void road(int x,int y,int r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
bool bfs()
{
    queue&lt;int&gt; Q;
    Q.push(s1);
    for(int i=0;i&lt;=127;++i) f[i]=0;
    f[s1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].r!=0)
            {
                f[a[i].m]=f[k]+1;
                Q.push(a[i].m);
            }
        }
    }
    return f[s2]!=0;
}
int dfs(int x,int r)
{
    if(x==s2) return r;
    int s=0;
    for(int i=t[x];i!=0;i=a[i].q)
    {
        if(f[a[i].m]==f[x]+1&amp;&amp;a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
        }
    }
    return s;
}
int main()
{
    scanf(&quot;%d&quot;,&amp;m);
    s1='A';
    s2='Z';
    for(int i=1;i&lt;=m;++i)
    {
        char x,y;
        x=getchar();
        while((x&lt;'A'||x&gt;'Z')&amp;&amp;(x&lt;'a'||x&gt;'z')) x=getchar();
        y=getchar();
        while((y&lt;'A'||y&gt;'Z')&amp;&amp;(y&lt;'a'||y&gt;'z')) y=getchar();
        int r;
        scanf(&quot;%d&quot;,&amp;r);
        road(int(x),int(y),r);
        road(int(y),int(x),0);
    }
    int r=0;
    while(bfs())
    {
        r+=dfs(s1,1e9);
    }
    printf(&quot;%d&quot;,r);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2740 [USACO4.2]草地排水Drainage Ditches]]></title>
        <id>https://2745518585.github.io/post/solution-P2704/</id>
        <link href="https://2745518585.github.io/post/solution-P2704/">
        </link>
        <updated>2022-04-13T05:43:36.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P2740">P2740 [USACO4.2]草地排水Drainage Ditches</a></p>
<h2 id="分析">分析</h2>
<p>  最大流的模板。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
int n,m,p=1,t[10001],f[10001];
struct str
{
    int m,q;
    ll w;
}a[10000001];
void road(int x,int y,ll w)
{
    a[++p].m=y;
    a[p].w=w;
    a[p].q=t[x];
    t[x]=p;
}
bool bfs()
{
    queue&lt;int&gt; q;
    q.push(1);
    for(int i=1;i&lt;=n;++i) f[i]=0;
    f[1]=1;
    while(!q.empty())
    {
        int k=q.front();
        q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].w&gt;0)
            {
                f[a[i].m]=f[k]+1;
                q.push(a[i].m);
            }
        }
    }
    if(f[n]!=0) return true;
    return false;
}
ll dfs(int x,ll w)
{
    if(x==n) return w;
    ll v=0;
    for(int i=t[x];i!=0&amp;&amp;w!=0;i=a[i].q)
    {
        if(f[a[i].m]==f[x]+1&amp;&amp;a[i].w&gt;0)
        {
            ll z=dfs(a[i].m,min(w,a[i].w));
            a[i].w-=z;
            a[i^1].w+=z;
            w-=z;
            v+=z;
        }
    }
    if(v==0) f[x]=0;
    return v;
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
    for(int i=1;i&lt;=m;++i)
    {
        int x,y;
        ll w;
        scanf(&quot;%d%d%lld&quot;,&amp;x,&amp;y,&amp;w);
        road(x,y,w);
        road(y,x,0);
    }
    ll w=0;
    while(bfs()==true)
    {
        w+=dfs(1,1e18);
    }
    printf(&quot;%lld&quot;,w);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1343 地震逃生]]></title>
        <id>https://2745518585.github.io/post/solution-P1343/</id>
        <link href="https://2745518585.github.io/post/solution-P1343/">
        </link>
        <updated>2022-04-13T05:37:16.000Z</updated>
        <content type="html"><![CDATA[<p>  <a href="https://www.luogu.com.cn/problem/P1343">P1343 地震逃生</a></p>
<h2 id="分析">分析</h2>
<p>  这道题我们把学生看成流量，可以发现这道题就是最大流模板题，注意处理分的批数。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
int n,m,p=1,t[10001],f[10001];
struct str
{
    int m,q,w;
}a[100001];
void road(int x,int y,int w)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].w=w;
}
bool bfs()
{
    queue&lt;int&gt; q;
    q.push(1);
    for(int i=1;i&lt;=n;++i) f[i]=0;
    f[1]=1;
    while(!q.empty())
    {
        int k=q.front();
        q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&amp;&amp;a[i].w&gt;0)
            {
                f[a[i].m]=f[k]+1;
                q.push(a[i].m);
            }
        }
    }
    if(f[n]!=0) return true;
    return false;
}
int dfs(int x,int w)
{
    if(x==n) return w;
    int s=0;
    for(int i=t[x];i!=0;i=a[i].q)
    {
        if(f[a[i].m]==f[x]+1&amp;&amp;a[i].w&gt;0)
        {
            int z=dfs(a[i].m,min(w,a[i].w));
            if(z!=0)
            {
                a[i].w-=z;
                a[i^1].w+=z;
                w-=z;
                s+=z;
            }
            else f[a[i].m]=0;
        }
    }
    return s;
}
int main()
{
    int r;
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;r);
    for(int i=1;i&lt;=m;++i)
    {
        int x,y,w;
        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;w);
        road(x,y,w);
        road(y,x,0);
    }
    int s=0;
    while(bfs()==true)
    {
        s+=dfs(1,1e9);
    }
    if(s==0) printf(&quot;Orz Ni Jinan Saint Cow!&quot;);
    else printf(&quot;%d %d&quot;,s,int(ceil(r*1.0/s)));
}
</code></pre>
]]></content>
    </entry>
</feed>