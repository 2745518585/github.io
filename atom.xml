<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2745518585.github.io</id>
    <title>赵悦岑&apos;s Blog</title>
    <updated>2022-02-14T03:26:49.229Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2745518585.github.io"/>
    <link rel="self" href="https://2745518585.github.io/atom.xml"/>
    <subtitle>好好刷题，天天向上！</subtitle>
    <logo>https://2745518585.github.io/images/avatar.png</logo>
    <icon>https://2745518585.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 赵悦岑&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[5.2.1图的连通性]]></title>
        <id>https://2745518585.github.io/post/5.2.1/</id>
        <link href="https://2745518585.github.io/post/5.2.1/">
        </link>
        <updated>2022-02-13T12:12:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1知识讲解">1.知识讲解</h2>
<p>  在一个图中，如果有一条由边组成的路连接顶点A与顶点B（除了A与B其他经过的顶点均不相同），A与B之间就存在一条路径，也称A与B是连通的。没有边权时，路径长度就是这条路径上边的数目；有边权时路径长度就是路径上的边权之和。如果这个路径起点与终点相同，那么这条路径叫做回路或环。<br>
  如果在一个无向图中，任意两个不相同的顶点都是连通的，那么称这个无向图为连通图。<br>
  如果在一个有向图中，对于任意两个不相同的顶点A、B，都存在A到B的路径与B到A的路径，那么这个图叫做强连通图。<br>
<img src="https://2745518585.github.io/post-images/1644759312124.png" alt="" loading="lazy"><br>
图5.2.1-1(a) | 图5.2.1-1(b)<br>
  如图5.2-1其中图(b)就是一个连通图，而图(a)不是，图(d)是强连通图，而图(c)不是。<br>
  连通分量是指一个无向图的一个极大连通子图，连通分量中任意两个点都存在一条路径使这两个点可以互相到达（所以之前dfs的许多求块数的题的实质就是求连通分量的个数）。<br>
  强连通分量（以下简称SCC）是指一个有向图的一个极大连通子图，SCC中任意两个点都存在一条路径使这两个点可以互相到达。<br>
  如图5.2-2，图(a)有3个连通分量，图(b)有4个SCC（这三个单独的点都没有办法沿着一条路径回到自己）。<br>
<img src="https://2745518585.github.io/post-images/1644759389593.png" alt="" loading="lazy"><br>
  对于一个无向图，要求出它的所有连通分量，只需要用dfs遍历就好了（详见本书3.4 深搜算法），当然还可以用并查集求。代码如下：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
int n;
bool a[1000][1000],b[1000];     //a是邻接矩阵，b判断是否遍历过 
void dfs(int m)
{
    b[m]=true;      //标记已走过 
    for(int i=1;i&lt;=n;++i) 
    {
        if(a[m][i]&amp;&amp;!b[i])      //如果有一条边从x到达i且i没有被遍历过 
        {
            dfs(i);     //走到i	
        }
    }
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;++i)
    {
        for(int j=1;j&lt;=n;++j)
        {
            scanf(&quot;%d&quot;,&amp;a[i][j]);       //输入 
        }
    }
    for(int i=1;i&lt;=n;++i)
    {
        if(!b[i])       //寻找还没有遍历过的点 
        {
            dfs(i);     //从这个点开始遍历 
        }
    }
    return 0;
}
</code></pre>
<p>  而对于有向图，可以判断两个数是否可以互相到达，如果可以它们就在同一个SCC中，但是时间复杂度较高。我们还可以用Tarjan算法来求解。<br>
  Tarjan是一种基于dfs的一种算法，它可以用很少的时间（O(n+m)）求出一个有向图的所有SCC。定义三个整型数组b、c、d和一个布尔数组e，数组b储存每个点在搜索时被搜到的先后序号，即b[i]表示点i第几个被搜到（之后点的序号均指这个）；c[i]表示点i可以到达的点的序号的最小值；d是一个栈，储存的是当前已搜索到但是不在SCC中的点；e[i]=true表示点i是否已经被搜到在某一个SCC中，反之则点i还没有被搜到存在于任意一个SCC中。算法流程如下：<br>
  （1）找到一个未搜索过的点，开始搜索。<br>
  （2）将这个点x的b[x]与c[x]设置为这个点的搜索序号。<br>
  （3）将点x入栈。<br>
  （4）拓展点x。<br>
  （5）如果下一个点i没有搜过，拓展至点i，重复（2）-（7）。并如果点i的搜索完成后c[i]比c[x]小，就更新c[x]。<br>
  （6）如果下一个点i被搜过但是并没有已经被搜到在某一个SCC中，如果c[i]比c[x]小，就更新c[x]。<br>
  （7）如果点i不满足（5）与（6），跳过点i，拓展下一个点。<br>
  （8）如果b[x]与c[x]相等，即点x能到达的点的搜索序号最小的点是自己，表示发现了一个SCC，进行（9）-（10）；如果不相等，结束这个点的搜索，返回上一个点的搜索步骤（5）。<br>
  （9）计数器加一<br>
  （10）一次访问栈中的点直到访问到点x，访问到的点均在这个SCC中，全部标记e[]为真。<br>
  证明：如果c[x]=b[x]，表示从点x出发可以到达的点的序号的最小值为x，即从点x出发可以回到点x，其他的点均可到达点x并从点x到达任意点，所以这些点可以组成强连通子图。而点x可以到达的所有点中，如果有点不能回到点x，这些点必然已经存在于其他SCC中。如果还有更大的包含这些点的强连通子图，从点x出发到达的点的序号的最小值必然小于点x，就不会在点x就构建SCC，所以Tarjan算法是正确的。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m=0,q=0,s=0,  //n是点的个数，m是已搜索的点数，q是栈长度 
a[1001][1001],b[1001],c[1001],d[1001];  //意义见前文描述 
bool e[1001];       //意义见前文描述 
void dfs(int x)         //搜索
{
    ++m;
    b[x]=m;
    c[x]=m;
    ++q;
    d[q]=x;
    for(int i=1;i&lt;=n;++i)
    {
    	if(a[x][i]==true)
    	{
            if(b[i]==0)     //点i没有被遍历过 
            {
                dfs(i);     //搜索i 
                c[x]=min(c[x],c[i]);        //更新c[x] 
            }
            else if(e[i]==false)        //如果点i没有在强连通分量中 
            {
                c[x]=min(c[x],c[i]);        //更新c[x] 
            }
    	}
    }
    if(b[x]==c[x])      //如果已经发现强连通分量 
    {
    	++s;        //计数器加一 
    	while(d[q]!=x)      //扫描栈 
    	{
            e[d[q]]=true;       //标记这些点已经在强连通分量中 
            --q;        //把这些点移出栈 
    	}
    	e[x]=true;
    	--q;        //把点x移出栈 
    }
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;++i)
    {
        for(int j=1;j&lt;=n;++j)
        {
            scanf(&quot;%d&quot;,&amp;a[i][j]);       //输入 
        }
    }
    for(int i=1;i&lt;=n;++i)
    {
        if(b[i]==0)     //寻找还没有遍历过的点 
        {
            dfs(i);     //从这个点开始遍历 
        }
    }
    printf(&quot;%d&quot;,s);
    return 0;
}
</code></pre>
<h2 id="2例题分析">2.例题分析</h2>
<p>例5.2.1-1    机场建设<br>
【题目描述】<br>
  现有n个城市，两个城市之间有高铁或飞机两种交通方式，由于某些原因，一些地方不适合修高铁，只能通过飞机到达。现已存在m条单向高铁线路，每条高铁线路单向连接两个城市（保证不存在两条起点与终点相同的高铁线路，不存在起点与终点相同的高铁线路）。政府现在要在某些城市修建机场，每个机场可以到达其他任意一个机场。政府要使每个城市都可以直接或间接到达其他所有城市，至少要修建多少个机场？<br>
【输入格式】<br>
  第1行两个整数n和m。<br>
  接下来m行，每行两个数x，y，表示有一条高铁线路单向连接城市x与城市y。<br>
【输出格式】<br>
  一个数，表示至少需要修建多少个机场。<br>
【输入样例】<br>
  7 9<br>
  2 1<br>
  1 3<br>
  1 5<br>
  3 4<br>
  4 2<br>
  5 6<br>
  2 6<br>
  3 7<br>
  4 7<br>
【输出样例】<br>
  4<br>
  分析：这题的实质就是求SCC的个数，使用Tarjan算法即可。代码如下：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct str
{
    int m,q;
}a[100001];
int n,m=0,q=0,s=0,b[1001],c[1001],d[1001],t[1001];
bool e[1001];
void dfs(int x)
{
    ++m;
    b[x]=m;
    c[x]=m;
    ++q;
    d[q]=x;
    for(int i=t[x];i!=0;i=a[i].q)
    {
    	if(b[a[i].m]==0)
    	{
            dfs(a[i].m);
            c[x]=min(c[x],c[a[i].m]);
    	}
    	else if(e[a[i].m]==false)
    	{
            c[x]=min(c[x],c[a[i].m]);
    	}
    }
    if(b[x]==c[x]) 
    {
    	++s; 
    	while(d[q]!=x)
    	{
            e[q]=true;
            --q;
    	}
    	e[x]=true;
    	--q;
    }
}
int main()
{
    int p;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;p);
    for(int i=1;i&lt;=p;++i)
    {
        int x;
        scanf(&quot;%d%d&quot;,&amp;x,&amp;a[i].m);
        a[i].q=t[x];
        t[x]=i;
    }
    for(int i=1;i&lt;=n;++i)
    {
        if(b[i]==0)
        {
            dfs(i);
        }
    }
    printf(&quot;%d&quot;,s);
    return 0;
}
</code></pre>
<p>例5.2.1-2    <a href="https://www.luogu.com.cn/problem/P2835">刻录光盘</a>（2915）<br>
【题目描述】<br>
  在FJOI2010夏令营快要结束的时候，很多营员提出来要把整个夏令营期间的资料刻录成一张光盘给大家，以便大家回去后继续学习。组委会觉得这个主意不错！可是组委会一时没有足够的空光盘，没法保证每个人都能拿到刻录上资料的光盘，怎么办呢？！<br>
  DYJ分析了一下所有营员的地域关系，发现有些营员是一个城市的，其实他们只需要一张就可以了，因为一个人拿到光盘后，其他人可以带着U盘之类的东西去拷贝啊！<br>
他们愿意某一些人到他那儿拷贝资料，当然也可能不愿意让另外一些人到他那儿拷贝资料，这与我们FJOI宣扬的团队合作精神格格不入！！！<br>
  现在假设总共有N个营员（2≤N≤200），每个营员的编号为1~N。DYJ给每个人发了一张调查表，让每个营员填上自己愿意让哪些人到他那儿拷贝资料。当然，如果A愿意把资料拷贝给B，而B又愿意把资料拷贝给C，则一旦A获得了资料，则B，C都会获得资料。<br>
  现在，请你编写一个程序，根据回收上来的调查表，帮助DYJ计算出组委会至少要刻录多少张光盘，才能保证所有营员回去后都能得到夏令营资料？<br>
【输入格式】<br>
  先是一个数N，接下来的N行，分别表示各个营员愿意把自己获得的资料拷贝给其他哪些营员。即输入数据的第i+1行表示第i个营员愿意把资料拷贝给那些营员的编号，以一个0结束。如果一个营员不愿意拷贝资料给任何人，则相应的行只有1个0，一行中的若干数之间用一个空格隔开。<br>
【输出样例】<br>
  一个正整数，表示最少要刻录的光盘数。<br>
【样例输入】<br>
  8<br>
  2 4 8 0<br>
  3 0<br>
  1 0<br>
  5 0<br>
  1 0<br>
  1 0<br>
  1 0<br>
  0<br>
【样例输出】<br>
  2<br>
  分析：这道题虽然看似不是求SCC，但是也可以通过SCC来推出所需光盘个数。我们把人看做点，愿意给别人光盘的关系看做有向边。如果给一个人一个光盘，那么这个人对应的点所在的SCC中所有点都可以得到光盘。而如果一个点A可以由与它不在同一SCC中点B拓展得到，表示A所在的连通分量的入度不为0，就把点A所在的SCC标记一下。如果一个SCC的入度不为0，那么这个SCC一定可以从其他SCC中拷贝资料。实质上就是求有多少个SCC无法从其他SCC中拷贝资料，统计有多少个入度为0的SCC即可。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct str
{
    int m,q;
}a[100001];
int n,m=0,q=0,s=0,b[1001],c[1001],d[1001],
r[1001],t[1001];        //r[i]表示点i所在的强连通分量
bool e[1001],l[1001];       //l[i]表示强连通分量i的入度是否为0 
void dfs(int x)
{
    ++m;
    b[x]=m;
    c[x]=m;
    ++q;
    d[q]=x;
    for(int i=t[x];i!=0;i=a[i].q)
    {
    	if(b[a[i].m]==0)
    	{
            dfs(a[i].m);
            c[x]=min(c[x],c[a[i].m]);
    	}
    	else if(e[a[i].m]==false)
    	{
            c[x]=min(c[x],c[a[i].m]);
    	}
    }
    if(b[x]==c[x]) 
    {
    	++s; 
    	while(d[q]!=x)
    	{
            e[d[q]]=true;
            r[d[q]]=s;      //把这个强连通分量中的点都标记 
            --q;
    	}
    	e[x]=true;
    	r[x]=s;
    	--q;
    }
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    int k=0;
    for(int i=1;i&lt;=n;++i)
    {
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        while(x!=0)
        {
            ++k;
            a[k].m=x;
            a[k].q=t[i];
            t[i]=k;
            scanf(&quot;%d&quot;,&amp;x);
        }
    }
    for(int i=1;i&lt;=n;++i)
    {
        if(b[i]==0)
        {
            dfs(i);
        }
    }
    for(int i=1;i&lt;=n;++i)
    {
        for(int j=t[i];j!=0;j=a[j].q)
        {
            if(r[i]!=r[a[j].m])     //枚举连接两个强连通分量的点 
            {
                l[r[a[j].m]]=true;      //标记这个强连通分量入度不为0 
            }
        }
    }
    int w=0;
    for(int i=1;i&lt;=s;++i)
    {
        if(l[i]==false)     //枚举入度为0的强连通分量 
        {
            ++w;        //更新所需光盘数 
        }
    }
    printf(&quot;%d&quot;,w);
    return 0;
}
</code></pre>
<h2 id="3巩固练习">3.巩固练习</h2>
<p>练5.2.1-1    <a href="https://www.luogu.com.cn/problem/U190740">最佳作弊方案(cheat)</a><br>
【题目描述】<br>
  DC初赛屡次失利，今所以年的初赛DC准备用特殊手段来帮助DC学子通过初赛。DC的考室的座位共有m行n列，其中有一些考生是DC学子，另一些不是。两个相邻（前后左右四个方向）的DC学子可以相互传递答案，答案不能经过外校考生。考试期间每个考试最多可以有k个DC学子出来上厕所，顺便拿一份答案。DC想让每个考试能拿到答案的DC学子最多，但是有时必须放弃一些DC学子来保证更多人拿到答案。并且为了防止监考老师和监控发现，在有多种方案时，优先放弃序号较小的（每个考试的输入顺序，考生 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的序号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>×</mo><mi>m</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">(i-1)\times m+j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> ）。求每个考试最少放弃的DC学子的人数与这些学生的序号。<br>
【输入格式】<br>
  第一行三个数m，n，k。<br>
  下面m行，每行n个数0或1，0表示不是DC学子，1表示DC学子。<br>
【输出格式】<br>
  输出两行，第一行一个数q表示这个考室放弃的DC学子个数。第二行共q个数，表示放弃的DC学子的序号（从小到大输出）。<br>
【输入样例】<br>
  4 5 2<br>
  0 1 0 1 0<br>
  0 0 1 1 0<br>
  1 1 0 1 0<br>
  0 1 0 0 1<br>
【输出样例】<br>
  2<br>
  2 20<br>
【数据范围】<br>
  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>⩽</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo>⩽</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1 \leqslant m,n \leqslant 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78111em;vertical-align:-0.13667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83111em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><br>
  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>⩽</mo><mi>k</mi><mo>⩽</mo><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \leqslant k \leqslant m \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78111em;vertical-align:-0.13667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83111em;vertical-align:-0.13667em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span><br>
练5.2.1-2    <a href="https://www.luogu.com.cn/problem/U192237">不可能阶梯(imstair)</a><br>
【题目描述】<br>
  DC最近准备重新装修校园，征集各界人士的意见。东东想让DC的结构更加复杂，设计了一种非常奇怪的方案。在东东的设计图中，共有n个教室，m条通道连接这些教室，并且这些教室的高度并不一样，通道也可能是斜的。东东给出了每个通道的起点，终点与下坡还是水平。但是辰辰发现东东的方案有问题，存在“不可能阶梯”，但是辰辰并没办法找出所有“不可能阶梯”，请你帮东东和辰辰找出高度矛盾的教室的个数（即存在一条不上坡的路连接同一个教室，路线可以经过重复边）。<br>
【输入格式】<br>
  第一行两个数n，m1，m2，表示教室数和水平通道数、下坡通道数。<br>
  接下来m1行，每行两个数x，m，表示每个水平通道的起点、终点。<br>
  接下来m2行，每行两个数x，m，表示每个下坡通道的起点、终点。<br>
【输出格式】<br>
  一个整数，表示高度不可能的教室数。<br>
【输入样例】<br>
  8 2 5<br>
  1 6<br>
  2 4<br>
  1 2<br>
  1 7<br>
  3 5<br>
  4 1<br>
  8 7<br>
【输出样例】<br>
  4<br>
【数据范围】<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>⩽</mo><mi>n</mi><mo>⩽</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1 \leqslant n \leqslant 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78111em;vertical-align:-0.13667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>⩽</mo><mi>m</mi><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mn>2</mn><mo>⩽</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">1 \leqslant m1,m2 \leqslant 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78111em;vertical-align:-0.13667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><br>
练5.2.1-3    珍珠(2916)<br>
【题目描述】<br>
  有n颗形状和大小都一致的珍珠，它们的重量都不相同。n为整数，所有的珍珠从1到n编号。你的任务是发现哪颗珍珠的重量刚好处于正中间，即在所有珍珠的重量中，该珍珠的重量列(n+1)/2位。下面给出将一对珍珠进行比较的办法：<br>
  给你一架天平用来比较珍珠的重量，我们可以比出两个珍珠哪个更重一些，在作出一系列的比较后，我们可以将某些肯定不具备中间重量的珍珠拿走。<br>
  例如，下列给出对5颗珍珠进行四次比较的情况：<br>
  1、珍珠2比珍珠1重<br>
  2、珍珠4比珍珠3重<br>
  3、珍珠5比珍珠1重<br>
  4、珍珠4比珍珠2重<br>
  根据以上结果，虽然我们不能精确地找出哪个珍珠具有中间重量，但我们可以肯定珍珠1和珍珠4不可能具有中间重量，因为珍珠2、4、5比珍珠1重，而珍珠1、2、3比珍珠4轻，所以我们可以移走这两颗珍珠。<br>
  写一个程序统计出共有多少颗珍珠肯定不会是中间重量。<br>
【输入格式】<br>
  第一行包含两个用空格隔开的整数N和M，其中1≤N≤99，且N为奇数，M表示对珍珠进行的比较次数，接下来的M行每行包含两个用空格隔开的整数x和y，表示珍珠x比珍珠y重。<br>
【输出格式】<br>
  一行包含一个整数，表示不可能是中间重量的珍珠的总数。<br>
【样例输入】<br>
  5 4<br>
  2 1<br>
  4 3<br>
  5 1<br>
  4 2<br>
【样例输出】<br>
  2</p>
]]></content>
    </entry>
</feed>